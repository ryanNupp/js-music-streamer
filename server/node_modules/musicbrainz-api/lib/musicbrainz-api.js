import * as assert from 'assert';
import { StatusCodes as HttpStatus } from 'http-status-codes';
import Debug from 'debug';
export { XmlMetadata } from './xml/xml-metadata.js';
export { XmlIsrc } from './xml/xml-isrc.js';
export { XmlIsrcList } from './xml/xml-isrc-list.js';
export { XmlRecording } from './xml/xml-recording.js';
import { DigestAuth } from './digest-auth.js';
import { RateLimitThreshold } from 'rate-limit-threshold';
import * as mb from './musicbrainz.types.js';
import got from 'got';
import { CookieJar } from 'tough-cookie';
export * from './musicbrainz.types.js';
import { promisify } from 'util';
const debug = Debug('musicbrainz-api');
export class MusicBrainzApi {
    static fetchCsrf(html) {
        return {
            sessionKey: MusicBrainzApi.fetchValue(html, 'csrf_session_key'),
            token: MusicBrainzApi.fetchValue(html, 'csrf_token')
        };
    }
    static fetchValue(html, key) {
        let pos = html.indexOf(`name="${key}"`);
        if (pos >= 0) {
            pos = html.indexOf('value="', pos + key.length + 7);
            if (pos >= 0) {
                pos += 7;
                const endValuePos = html.indexOf('"', pos);
                return html.substring(pos, endValuePos);
            }
        }
    }
    constructor(_config) {
        this.config = {
            baseUrl: 'https://musicbrainz.org'
        };
        Object.assign(this.config, _config);
        const cookieJar = new CookieJar();
        this.getCookies = promisify(cookieJar.getCookies.bind(cookieJar));
        // @ts-ignore
        this.options = {
            prefixUrl: this.config.baseUrl,
            timeout: {
                read: 20 * 1000
            },
            headers: {
                'User-Agent': `${this.config.appName}/${this.config.appVersion} ( ${this.config.appContactInfo} )`
            },
            cookieJar: cookieJar
        };
        this.rateLimiter = new RateLimitThreshold(15, 18);
    }
    async restGet(relUrl, query = {}) {
        query.fmt = 'json';
        const delay = await this.rateLimiter.limit();
        debug(`Client side rate limiter activated: cool down for ${Math.round(delay / 100) / 10} s...`);
        const response = await got.get('ws/2' + relUrl, {
            ...this.options,
            searchParams: query,
            responseType: 'json',
            retry: {
                limit: 10
            }
        });
        return response.body;
    }
    lookup(entity, mbid, inc = []) {
        return this.restGet(`/${entity}/${mbid}`, { inc: inc.join(' ') });
    }
    browse(entity, query) {
        return this.restGet(`/${entity}`, query);
    }
    search(entity, query) {
        const urlQuery = { ...query };
        if (typeof query.query === 'object') {
            urlQuery.query = makeAndQueryString(query.query);
        }
        if (Array.isArray(query.inc)) {
            urlQuery.inc = urlQuery.inc.join(' ');
        }
        return this.restGet('/' + entity + '/', urlQuery);
    }
    // ---------------------------------------------------------------------------
    async postRecording(xmlMetadata) {
        return this.post('recording', xmlMetadata);
    }
    async post(entity, xmlMetadata) {
        if (!this.config.appName || !this.config.appVersion) {
            throw new Error(`XML-Post requires the appName & appVersion to be defined`);
        }
        const clientId = `${this.config.appName.replace(/-/g, '.')}-${this.config.appVersion}`;
        const path = `ws/2/${entity}/`;
        // Get digest challenge
        let digest;
        let n = 1;
        const postData = xmlMetadata.toXml();
        do {
            await this.rateLimiter.limit();
            const response = await got.post(path, {
                ...this.options,
                searchParams: { client: clientId },
                headers: {
                    authorization: digest,
                    'Content-Type': 'application/xml'
                },
                body: postData,
                throwHttpErrors: false
            });
            if (response.statusCode === HttpStatus.UNAUTHORIZED) {
                // Respond to digest challenge
                const auth = new DigestAuth(this.config.botAccount);
                const relPath = response.requestUrl.pathname; // Ensure path is relative
                digest = auth.digest(response.request.method, relPath, response.headers['www-authenticate']);
                ++n;
            }
            else {
                break;
            }
        } while (n++ < 5);
    }
    async login() {
        var _a, _b;
        assert.ok((_a = this.config.botAccount) === null || _a === void 0 ? void 0 : _a.username, 'bot username should be set');
        assert.ok((_b = this.config.botAccount) === null || _b === void 0 ? void 0 : _b.password, 'bot password should be set');
        if (this.session && this.session.loggedIn) {
            for (const cookie of await this.getCookies(this.options.prefixUrl)) {
                if (cookie.key === 'remember_login') {
                    return true;
                }
            }
        }
        this.session = await this.getSession();
        const redirectUri = '/success';
        const formData = {
            username: this.config.botAccount.username,
            password: this.config.botAccount.password,
            csrf_session_key: this.session.csrf.sessionKey,
            csrf_token: this.session.csrf.token,
            remember_me: 1
        };
        const response = await got.post('login', {
            ...this.options,
            followRedirect: false,
            searchParams: {
                returnto: redirectUri
            },
            form: formData
        });
        const success = response.statusCode === HttpStatus.MOVED_TEMPORARILY && response.headers.location === redirectUri;
        if (success) {
            this.session.loggedIn = true;
        }
        return success;
    }
    /**
     * Logout
     */
    async logout() {
        const redirectUri = '/success';
        const response = await got.get('logout', {
            ...this.options,
            followRedirect: false,
            searchParams: {
                returnto: redirectUri
            }
        });
        const success = response.statusCode === HttpStatus.MOVED_TEMPORARILY && response.headers.location === redirectUri;
        if (success && this.session) {
            this.session.loggedIn = true;
        }
        return success;
    }
    /**
     * Submit entity
     * @param entity Entity type e.g. 'recording'
     * @param mbid
     * @param formData
     */
    async editEntity(entity, mbid, formData) {
        var _a, _b;
        await this.rateLimiter.limit();
        this.session = await this.getSession();
        formData.csrf_session_key = this.session.csrf.sessionKey;
        formData.csrf_token = this.session.csrf.token;
        formData.username = (_a = this.config.botAccount) === null || _a === void 0 ? void 0 : _a.username;
        formData.password = (_b = this.config.botAccount) === null || _b === void 0 ? void 0 : _b.password;
        formData.remember_me = 1;
        const response = await got.post(`${entity}/${mbid}/edit`, {
            ...this.options,
            form: formData,
            followRedirect: false
        });
        if (response.statusCode === HttpStatus.OK)
            throw new Error(`Failed to submit form data`);
        if (response.statusCode === HttpStatus.MOVED_TEMPORARILY)
            return;
        throw new Error(`Unexpected status code: ${response.statusCode}`);
    }
    /**
     * Set URL to recording
     * @param recording Recording to update
     * @param url2add URL to add to the recording
     * @param editNote Edit note
     */
    async addUrlToRecording(recording, url2add, editNote = '') {
        var _a;
        const formData = {};
        formData['edit-recording.name'] = recording.title; // Required
        formData['edit-recording.comment'] = recording.disambiguation;
        formData['edit-recording.make_votable'] = true;
        formData['edit-recording.url.0.link_type_id'] = url2add.linkTypeId;
        formData['edit-recording.url.0.text'] = url2add.text;
        (_a = recording.isrcs) === null || _a === void 0 ? void 0 : _a.forEach((isrcs, i) => {
            formData[`edit-recording.isrcs.${i}`] = isrcs;
        });
        formData['edit-recording.edit_note'] = editNote;
        return this.editEntity('recording', recording.id, formData);
    }
    /**
     * Add ISRC to recording
     * @param recording Recording to update
     * @param isrc ISRC code to add
     */
    async addIsrc(recording, isrc) {
        const formData = {};
        formData[`edit-recording.name`] = recording.title; // Required
        if (!recording.isrcs) {
            throw new Error('You must retrieve recording with existing ISRC values');
        }
        if (recording.isrcs.indexOf(isrc) === -1) {
            recording.isrcs.push(isrc);
            for (const i in recording.isrcs) {
                formData[`edit-recording.isrcs.${i}`] = recording.isrcs[i];
            }
            return this.editEntity('recording', recording.id, formData);
        }
    }
    // -----------------------------------------------------------------------------------------------------------------
    // Helper functions
    // -----------------------------------------------------------------------------------------------------------------
    /**
     * Add Spotify-ID to MusicBrainz recording.
     * This function will automatically lookup the recording title, which is required to submit the recording URL
     * @param recording MBID of the recording
     * @param spotifyId Spotify ID
     * @param editNote Comment to add.
     */
    addSpotifyIdToRecording(recording, spotifyId, editNote) {
        assert.strictEqual(spotifyId.length, 22);
        return this.addUrlToRecording(recording, {
            linkTypeId: mb.LinkType.stream_for_free,
            text: 'https://open.spotify.com/track/' + spotifyId
        }, editNote);
    }
    async getSession() {
        const response = await got.get('login', {
            ...this.options,
            followRedirect: false, // Disable redirects
            responseType: 'text'
        });
        return {
            csrf: MusicBrainzApi.fetchCsrf(response.body)
        };
    }
}
export function makeAndQueryString(keyValuePairs) {
    return Object.keys(keyValuePairs).map(key => `${key}:"${keyValuePairs[key]}"`).join(' AND ');
}
//# sourceMappingURL=musicbrainz-api.js.map